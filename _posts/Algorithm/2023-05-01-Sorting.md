---
title:  "Sorting"
categories: algorithm
tag: [Data_Structure, python]
author_profile: false
typora-root-url: ../
search: true
use_math: true
---

# Selection Sort Algorithm

Selection sort is [a sorting algorithm](https://www.programiz.com/dsa/sorting-algorithm) that selects the smallest element from an unsorted list in each iteration and places that element at the beginning of the unsorted list.

## Working of Selection Sort

1. Set the first element as `minimum`. 
2. After each iteration, `minimum` is placed in the front of the unsorted list.
3. Swap the first with minimum.
4. For each iteration, indexing starts from the first unsorted element. Step 1 to 3 are repeated until all the elements are placed at their correct positions.

![image-20230501140528653](/images/2023-05-01-Sorting/image-20230501140528653.png)

![image-20230501140558510](/images/2023-05-01-Sorting/image-20230501140558510.png)

![image-20230501140615855](/images/2023-05-01-Sorting/image-20230501140615855.png)

![image-20230501140626772](/images/2023-05-01-Sorting/image-20230501140626772.png)

## Source code

```python
array  [7,5,9,0,3,1,6,2,4,8]

for i in range(len(array)):
	min_index = i  # 가장 작은 원소의 인덱스
    for j in range(i+1, len(array)):
    	if array[min_index]>array[j]:
        	min_index = j
    array[i], array[min_index] = array[min_index], array[i]  # swap
print(array)

#[실행 결과]
[0,1,2,3,4,5,6,7,8,9]
```

## Time complexity

- 선택 정렬은 N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다.
- 구현 방식에 따라서 사소한 오차는 있을 수 있지만, 전체 연산 횟수는 $N + (N-1) + (N-2) + ... + 2 = (N^2 + N + 2)/2 = O(N^2)$.

# Inserting Sorting Algorithm

Insertion sort is [a sorting algorithm](https://www.programiz.com/dsa/sorting-algorithm) that places an unsorted element at its suitable place in each iteration.

- Insertion sort works similarly as we sort cards in our hands in a card game.
- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입한다.
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작한다.

## Working of Sorting Sort

- The first element in the array is assumed to be sorted. Take the second element and store it separately in `key`.
- Compare `key` with the first element. If the first element is greater than `key`, then key is placed in front of the first element.
- Now, the first two elements are sorted. Take the third element and compare it with the elements on the left of it. Placed it just behind the element smaller than it. If there is no element smaller than it, then place it at the beginning of the array.
- Similarly, place every unsorted element at its correct position.

`[Step 0]` 첫 번째 데이터 '7'은 그 자체로 정렬이 되어 있다고 판단하고, 두 번째 데이터인 '5'가 어떤 위치로 들어갈지 판단한다. '7'의 왼쪽으로 들어가거나 오른쪽으로 들어가거나 두 경우만 존재한다.
![img](https://velog.velcdn.com/images/yeahxne/post/f8fec41c-b088-4f99-a8dc-5f11fcd52279/image.png)

`[Step 1]` 이어서 '9'가 어떤 위치로 들어갈지 판단한다.
![img](https://velog.velcdn.com/images/yeahxne/post/753b01b4-249f-47dd-8689-f41a0106cd2e/image.png)

```
'9'는 차례대로 왼쪽에 있는 데이터와 비교해서 왼쪽 데이터보다 더 작다면 위치를 바꿔 주고 그렇지 않다면 그냥 그자리에 머물러 있도록 한다.`
`'9'는 '7'보다 더 크기 때문에 현재 위치 그대로 내버려둔다.
```

`[Step 2]` 이어서 '0'이 어떤 위치로 들어갈지 판단한다.
![img](https://velog.velcdn.com/images/yeahxne/post/e7382d30-57d3-4a5b-920d-17f973437b2b/image.png)

```
'0'은 '9','7','5'와 비교했을 때 모두 작기 때문에 '5'의 왼쪽에 위치한다.
```

<img src="https://velog.velcdn.com/images/yeahxne/post/03ff1c29-3dc4-4e75-8ca0-41156faf1a33/image.png" alt="img" style="zoom:200%;" />

## Source code

```python
array = [7,5,9,0,3,1,6,2,4,8]

for i in range(1, len(array)):  # 인덱스 i부터 1까지 1씩 감소하며 반복하는 문법
	for j in range(i, 0, -1):  # 한 칸씩 왼쪽으로 이동
    	if array[j] < array[j-1]:
        	array[j], array[j-1] = array[j-1], array[j]
        else:  # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
        	break

print(array) #[0,1,2,3,4,5,6,7,8,9]
```

## Time Complexity

- 삽입 정렬의 시간 복잡도는 $O(N^2)$이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용된다.
- 삽입 정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다.
  `최선의 경우 O(N)의 시간 복잡도를 가진다.`

![image-20230501143030904](/images/2023-05-01-Sorting/image-20230501143030904.png)